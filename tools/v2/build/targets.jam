#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.


#   Supports 'abstract' targets, which are targets explicitly defined in Jamfile.
#
#   Abstract targets are represented by classes derived from 'abstract-target' class. 
#   The first abstract target is 'project-target', which is created for each
#   Jamfile, and can be obtained by the 'target' rule in the Jamfile's module.
#   (see project.jam). 
#
#   Project targets keep a list of 'main-target' instances.
#   A main target is what the user explicitly defines in a Jamfile. It is
#   possible to have several definitions for a main target, for example to have
#   different lists of sources for different platforms. So, main targets
#   keep a list of alternatives.
#
#   Each alternative is an instance of 'abstract-target'. When a main target
#   subvariant is defined by some rule, that rule will decide what class to
#   use, create an instance of that class and add it to the list of alternatives
#   for the main target.
#
#   Rules supplied by the build system will use only targets derived
#   from 'basic-target' class, which will provide some default behaviour.
#   There will be two classes derived from it, 'make-target', created by the
#   'make' rule, and 'typed-target', created by rules such as 'exe' and 'dll'.

#
#                         +------------------------+
#                         |abstract-target         |
#                         +========================+
#                         |name                    |
#                         |project                 |                                   
#                         |                        |                                   
#                         |generate(properties) = 0|                                   
#                         +-----------+------------+                                   
#                                     |                                                
#                                     ^                                                
#                                    / \                                               
#                                   +-+-+                                              
#                                     |                                                
#                                     |                                                
#            +------------------------+------+------------------------------+          
#            |                               |                              |          
#            |                               |                              |          
# +----------+-----------+            +------+------+                +------+-------+  
# | project-target       |            | main-target |                | basic-target |  
# +======================+ 1        * +=============+  alternatives  +==============+  
# | generate(properties) |o-----------+ generate    |<>------------->| generate     |  
# | main-target          |            +-------------+                | construct = 0|
# +----------------------+                                           +--------------+  
#                                                                           |          
#                                                                           ^          
#                                                                          / \         
#                                                                         +-+-+        
#                                                                           |          
#                                                                           |          
#                 ...--+----------------+------------------+----------------+---+      
#                      |                |                  |                    |      
#                      |                |                  |                    |      
#               ... ---+-----+   +------+-------+   +------+------+    +--------+-----+
#                            |   | typed-target |   | make-target |    | stage-target |
#                            .   +==============+   +=============+    +==============+
#                            .   | construct    |   | construct   |    | construct    |
#                                +--------------+   +-------------+    +--------------+

import "class" : new ;
import sequence ;
import regex ;
import property ;
import errors ;
import common ;
import property-set ;
import project ;
import feature ;
import virtual-target ;
import path ;
import set ;
import assert ;

# Base class for all abstract targets.
class abstract-target 
{
    import project assert "class" errors ;    
        
    rule __init__ ( name      # name of the target in Jamfile
        : project-target      # the project target to which this one belongs
    )
    {        
        assert.true class.is-a $(project-target) : project-target ;
        # Note: it might seem that we don't need either name or project at all.
        # However, there are places where we really need it. One example is error
        # messages which should name problematic targets. Another is setting correct
        # paths for sources and generated files.
        
        self.name = $(name) ;
        self.project = $(project-target) ;
        self.location = [ errors.nearest-user-location ] ;
    }    
    
    # Returns the name of this target.
    rule name ( )
    {
        return $(self.name) ;
    }
    
    # Returns the project for this target.
    rule project ( )
    {
        return $(self.project) ;
    }
    
    # Return the location where the target was declared
    rule location ( )
    {
        return $(self.location) ;
    }
            
    # Returns a user-readable name for this target.
    rule full-name ( )
    {
        local location = [ $(self.project).get location ] ;
        return $(location)/$(self.name) ;
    }
        
    # Takes a property set.  Generates virtual targets for this abstract
    # target, using the specified properties, unless a different value of some
    # feature is required by the target. 
    # On
    # success, returns: 
    # - a property-set with the usage requirements to be
    #   applied to dependents 
    # - a list of produced virtual targets, which may be
    #    empty.  
    # If 'property-set' are empty, performs default build of this
    # target, in a way specific to derived class.
    rule generate ( property-set )
    {
        errors.error "method should be defined in derived classes" ;
    }
    
    rule rename ( new-name )
    {
        self.name = $(new-name) ;
    }        
}

if --debug-building in [ modules.peek : ARGV ]            
{
    modules.poke : .debug-building : true ;
}


rule indent ( )
{
    return $(.indent:J="") ;
}

rule increase-indent ( )
{
    .indent += "    " ;
}

rule decrease-indent ( )
{
    .indent = $(.indent[2-]) ;
}

#  Project target class (derived from 'abstract-target')
#
#  This class these responsibilities:
#  - maintaining a list of main target in this project and
#    building it
#
#  Main targets are constructed in two stages:
#  - When Jamfile is read, a number of calls to 'add-alternative' is made.
#    At that time, alternatives can also be renamed to account for inline
#    targets.
#  - The first time 'main-target' or 'has-main-target' rule is called,
#    all alternatives are enumerated an main targets are created.
class project-target : abstract-target 
{
    import project targets ;
    import path ;
    import print ;
    import property-set ;
    import set : difference : set.difference ;
    import sequence ;
    import "class" : new ;
    import errors ;
        
    rule __init__ ( name : project-module parent-project ?
        : requirements * : default-build * )
    {    
        abstract-target.__init__ $(name) : $(__name__) ;
        
        self.project-module = $(project-module) ;
        self.location = [ project.attribute $(project-module) location ] ;
        self.requirements = $(requirements) ;
        self.default-build = $(default-build) ;
                        
        if $(parent-project)
        {            
            inherit $(parent-project) ;
        }        
    }

    # This is needed only by the 'make' rule. Need to find the
    # way to make 'make' work without this method.
    rule project-module ( )
    {
        return $(self.project-module) ;
    }
        
    rule get ( attribute )    
    {
        return [ project.attribute $(self.project-module) $(attribute) ] ;
    }

    rule build-dir ( )
    {
        if ! $(self.build-dir)
        {            
            self.build-dir = [ get build-dir ] ;
            if ! $(self.build-dir)
            {
                self.build-dir = [ path.join 
                    [ $(self.project).get location ]
                      bin
                ] ;
            }
        }
        return $(self.build-dir) ;
    }        
    
    # Generates all possible targets contained in this project.
    rule generate ( property-set * )
    {
        if [ modules.peek : .debug-building ] 
        {
            ECHO [ targets.indent ] "building project" [ name ] " ('$(__name__)') with" [ $(property-set).raw ] ;
            targets.increase-indent ;
        }
                
        local usage-requirements = [ property-set.empty ] ;
        local targets ;
                
        for local t in [ targets-to-build ] 
        {
            local g = [ $(t).generate $(property-set) ] ;
            usage-requirements = [ $(usage-requirements).add $(g[1]) ] ;
            targets += $(g[2-]) ;
        }
        targets.decrease-indent ;
        return $(usage-requirements) [ sequence.unique $(targets) ] ;        
    }
        
    # Computes and returns a list of abstract-target instances which
    # must be built when this project is built.
    rule targets-to-build ( )
    {
        local result ;
        
        if ! $(self.built-main-targets)
        {
            build-main-targets ;
        }
        
        # Collect all main targets here, except for "explicit" ones.
        for local t in $(self.main-targets)
        {
            if ! [ $(t).name ] in $(self.explicit-targets)
            {                    
                result += $(t) ;
            }
        }

        # Collect all projects referenced via "projects-to-build" attribute.
        local self-location = [ get location ] ;
        for local pn in [ get projects-to-build ]
        {
            local p = [ project.module-name [ path.join $(self-location) $(pn) ] ] ;
            result += [ project.target $(p) ] ;
        }
                        
        return $(result) ;
    }
    
    # Add 'target' to the list of targets in this project that should be build
    # only by explicit request
    rule mark-target-as-explicit ( target-name )
    {
        # Record the name of the target, not instance, since this
        # rule is called before main target instaces are created.
        self.explicit-targets += $(target-name) ;
    }
    
    # Add new target alternative
    rule add-alternative ( target-instance )
    {
        if $(self.built-main-targets)
        {
            errors.error "add-alternative called when main targets are already created." 
              : "in project" [ full-name ] ;
        }        
        self.alternatives += $(target-instance) ;
    }
    
            
    # Returns a 'main-target' class instance corresponding to the 'name'.
    rule main-target ( name )
    {
        if ! $(self.built-main-targets)
        {
            build-main-targets ;
        }
                        
        return $(self.main-target.$(name)) ;
    }

    # Tells if a main target with the specified name exists.
    rule has-main-target ( name )
    {
        if ! $(self.built-main-targets)
        {
            build-main-targets ;
        }
        
        if $(self.main-target.$(name)) 
        {
            return true ;
        } 
    }

    # Find and return the target with the specified id, treated
    # relative to self.
    rule find-really ( id )
    {
        local result ;    
        local project = $(self.project) ;
        local current-location = [ get location ] ;
        
        local split = [ MATCH (.*)//(.*) : $(id) ] ;        
        local project-part = $(split[1]) ;
        local target-part = $(split[2]) ;

        local extra-error-message ;
        if $(project-part)
        {
            # There's explicit project part in id. Looks up the
            # project and pass the request to it.
            local pm = [ project.find $(project-part) : $(current-location) ] ;
            if $(pm)
            {
                project-target = [ project.target $(pm) ] ;                
                result = [ $(project-target).find $(target-part) : no-error ] ;
            }                      
            else
            {
                extra-error-message = "error: could not find project '$(project-part)'" ;
            }            
        }
        else
        {   
            # Interpret as filename            
            result = [ new file-reference [ path.make $(id) ] : $(project) ] ;
 
            if ! [ $(result).exists ]
            {
                # File actually does not exist.
                # Reset 'target' so that an error is issued.
                result = ;
            }            
            
            # Interpret target-name as name of main target
            if ! $(result)
            {
                result = [ main-target $(id) ] ;
            }
            
            # Interpret id as project-id
            if ! $(result)
            {                
                local project-module = [ project.find $(id) : $(current-location) ] ;
                if $(project-module)
                {
                    result = [ project.target $(project-module) ] ;
                }                                
            }            
        }
                
        return $(result) ;
    }
    
    rule find ( id : no-error ? )
    {
        local v = $(.id.$(id)) ;
        if ! $(v)
        {
            v = [ find-really $(id) ] ;
            if ! $(v)
            {
                v = none ;
            }
            .id.$(id) = $(v) ;
        }
        
        if $(v) != none
        {
            return $(v) ;
        }        
        else
        {
            if ! $(no-error)
            {
                local current-location = [ get location ] ;
                ECHO "error: Unable to find file or target named" ;
                ECHO "error:     '$(id)'" ;
                ECHO "error: referred from project at" ;
                ECHO "error:     '$(current-location)'" ;
                ECHO $(extra-error-message) ;
                EXIT ;
            }            
        }        
    }
    

    
    rule build-main-targets ( )
    {
        self.built-main-targets = true ;
        for local a in $(self.alternatives)
        {
            local name = [ $(a).name ] ;
            local target = $(self.main-target.$(name)) ;
            if ! $(target)
            {
                local t = [ new main-target $(name) : $(self.project) ] ;
                self.main-target.$(name) = $(t) ;
                self.main-targets += $(t) ;
                target = $(self.main-target.$(name)) ;
            }
            
            $(target).add-alternative $(a) ;            
        }    
    }                            
    
    # Accessor, add a constant.
    rule add-constant (
        name # Variable name of the constant.
        : value + # Value of the constant.
        : type ? # Optional type of value.
        )
    {
        switch $(type)
        {
            case path :
              local r ;
              for local v in $(value)
              {                  
                v = [ path.root [ path.make $(v) ] $(self.location) ] ;
                # Now make the value absolute path
                v = [ path.root $(v) [ path.pwd ] ] ;
                # Constants should be in platform-native form
                v = [ path.native $(v) ] ;
                r += $(v) ;
              }                  
              value = $(r) ;
        }
        if ! $(name) in $(self.constants)
        {
            self.constants += $(name) ;
        }
        self.constant.$(name) = $(value) ;
        # Inject the constant in the scope of project-root module
        modules.poke $(self.project-module) : $(name) : $(value) ;
    }
    
    rule inherit ( parent )
    {
        for local c in [ modules.peek $(parent) : self.constants ] 
        {
            # No need to pass the type. Path constants were converted to
            # absolute paths already by parent.
            add-constant $(c) 
              : [ modules.peek $(parent) : self.constant.$(c) ] ;
        }       

        # Import rules from parent 
        local this-module = [ project-module ] ;
        local parent-module = [ $(parent).project-module ] ;
        # Don't import rules which comes from 'project-rules', they
        # must be imported localized.
        local user-rules = [ set.difference 
            [ RULENAMES $(parent-module) ] :
            [ RULENAMES project-rules ] ] ;
        IMPORT $(parent-module) : $(user-rules) : $(this-module) : $(user-rules) ;
        EXPORT $(this-module) : $(user-rules) ;
    }
    
    
    # Intern the constants from this project into the specified module.
    #
    rule intern-constants (
        target-module # The module to intern into.
        )
    {
        for local c in $(self.constants)
        {
            modules.poke $(target-module) : $(c) : $(self.constant.$(c)) ;
        }
    }

}


# Helper rules to detect cycles in main target references
local rule start-building ( main-target-instance )
{
    if $(main-target-instance) in $(.targets-being-built)
    {
        local names ;
        for local t in $(.targets-being-built) $(main-target-instance)
        {
            names += [ $(t).full-name ] ;
        }
        
        errors.error "Recursion in main target references" 
          : "the following target are being built currently:"
          : $(names) ;
    }
    .targets-being-built += $(main-target-instance) ;    
}

local rule end-building ( main-target-instance )
{
    .targets-being-built = $(.targets-being-built[1--2]) ;
}


# A named top-level target in Jamfile
class main-target : abstract-target
{
    import errors : error ;
    import assert ;
    import sequence ;    
    import print ;
    import build-request feature property-set ;
    import targets : start-building end-building ;
    import "class" : is-a ;
        
    rule __init__ ( name : project )
    {
        abstract-target.__init__ $(name) : $(project) ;
    }
    
        
    # Add a new alternative for this target
    rule add-alternative ( target )
    {
        local d = [ $(target).default-build ] ;
        if $(self.alternatives) && ( $(self.default-build) != $(d) )
        {
            errors.error "default build must be identical in all alternatives"
              : "main target is" [ full-name ]
              : "with" [ $(d).raw ]
              : "differing from previous default build" [ $(self.default-build).raw ] ;
        }
        else
        {
            self.default-build = $(d) ;
        }        
        self.alternatives += $(target) ;
    }

    # Returns the best viable alternative for this property-set
    # See the documentation for selection rules.
    local rule select-alternatives ( property-set )
    {
        # When selecting alternatives we have to consider defaults,
        # for example:
        #    lib l : l.cpp : <variant>debug ;
        #    lib l : l_opt.cpp : <variant>release ;
        # won't work unless we add default value <variant>debug.        
        property-set = [ $(p).add-defaults ] ;        
        
        # The algorithm: we keep the current best viable alternative.
        # When we've got new best viable alternative, we compare it
        # with the current one. 
        
        local best ;
        local best-properties ;
                        
        if $(self.alternatives[2-])
        {
            local bad ;
            local worklist = $(self.alternatives) ;    
            while $(worklist) && ! $(bad)
            {
                local v = $(worklist[1]) ; 
                local properties = [ $(v).match $(property-set) ] ;
                           
                if $(properties) != no-match
                {                                    
                    if ! $(best)
                    {
                        best = $(v) ;
                        best-properties = $(properties) ;
                    }
                    else
                    {                                                   
                        if $(properties) = $(best-properties)
                        {
                            bad = true ;
                        }
                        else if $(properties) in $(best-properties) 
                        {
                            # Do nothing, this alternative is worse
                        }
                        else if $(best-properties) in $(properties)
                        {
                            best = $(v) ;
                            best-properties = $(properties) ;
                        }
                        else 
                        {
                            bad = true ;
                        }                                                
                    }
                }
                worklist = $(worklist[2-]) ;                
            }
            if ! $(bad)
            {
                return $(best) ;
            }                                    
        }
        else
        {
            return $(self.alternatives) ;
        }        
    }
    
    
    rule apply-default-build ( property-set )
    {           
        # 1. First, see what properties from default-build
        # are already present in property-set. 
        
        local raw = [ $(property-set).raw ] ;
        local specified-features = $(raw:G) ;
        
        local defaults-to-apply ;
        for local d in [ $(self.default-build).raw ] 
        {
            if ! $(d:G) in $(specified-features)
            {
                defaults-to-apply += $(d) ; 
            }            
        }
        
        # 2. If there's any defaults to be applied, form the new
        # build request. Pass it throw 'expand-no-defaults', since
        # default-build might contain "release debug", which will
        # result in two property-sets.
        local result ;
        if $(defaults-to-apply)
        {
            properties = [ 
              build-request.expand-no-defaults 
                
                # We have to compress subproperties here to prevent
                # property lists like:
                #
                #    <toolset>msvc <toolset-msvc:version>7.1 <threading>multi
                #
                # from being expanded into:
                #
                #    <toolset-msvc:version>7.1/<threading>multi
                #    <toolset>msvc/<toolset-msvc:version>7.1/<threading>multi
                #
                # due to cross-product property combination.  That may
                # be an indication that
                # build-request.expand-no-defaults is the wrong rule
                # to use here.
                [ feature.compress-subproperties $(raw) ] 
                  $(defaults-to-apply)
            ] ;
              
            if $(properties)
            {                
                for local p in $(properties)
                {
                    result += [ property-set.create 
                        [ feature.expand [ feature.split $(p) ] ] ] ;
                }
            }
            else
            {
                result = [ property-set.empty ] ;
            }            
            
        }
        else
        {
            result = $(property-set) ;
        }
        return $(result) ;
    }
        
    # Select an alternative for this main target, by finding all alternatives
    # which requirements are satisfied by 'properties' and picking the one with
    # longest requirements set.
    # Returns the result of calling 'generate' on that alternative.
    rule generate ( property-set )
    {
        start-building $(__name__) ;

        # We want composite properties in build request act as if
        # all the properties it expands too are explicitly specified.
        property-set = [ $(property-set).expand ] ;
        
        local all-property-sets = [ apply-default-build $(property-set) ] ;
        local usage-requirements = [ property-set.empty ] ;
        local result ;
        for local p in $(all-property-sets)
        {
            local r = [ generate-really $(p) ] ;
            usage-requirements = [ $(usage-requirements).add $(r[1]) ] ;
            result += $(r[2-]) ;
        }
        end-building $(__name__) ;
        return $(usage-requirements) [ sequence.unique $(result) ] ;                
    }
        
    # Generates the main target with the given property set
    # and returns a list which first element is property-set object
    # containing usage-requirements of generated target and with
    # generated virtual target in other elements. It's possible
    # that no targets are generated.
    local rule generate-really ( property-set )
    {            
        local best-alternatives = [ select-alternatives $(property-set) ] ;
        if ! $(best-alternatives)
        {
            errors.error
                "failed to build" [ full-name ]
                "with properties" [ $(property-set).raw ]
                  "because no best-matching alternative could be found"
                  ; 
            return [ property-set.empty ] ;
        }
        else
        {
            local result = [ $(best-alternatives).generate $(property-set) ] ;
                        
            # Now return virtual targets for the only alternative
            return $(result) ;
        }        
    }
    
    rule rename ( new-name )
    {
        abstract-target.rename $(new-name) ;
        for local a in $(self.alternatives)
        {
            $(a).rename $(new-name) ;
        }
        
    }
    
}

# Abstract target which refers to a source file.
# This is artificial creature; it's usefull so that sources to 
# a target can be represented as list of abstract target instances.
class file-reference : abstract-target 
{
    import virtual-target ;
    import property-set ;
    import path ;
    
    rule __init__ ( file : project )
    {
        abstract-target.__init__ $(file) : $(project) ;
    }
    
    rule generate ( properties )
    {
         return [ property-set.empty ] 
                [ virtual-target.from-file $(self.name)
                                         : [ location ]
                                         : $(self.project) ] ;        
    }    

    # Returns true if the referred file really exists;
    rule exists ( )
    {
        location ;
        return $(self.file-path) ;
    }

    # Returns the location of target. Needed by 'testing.jam'
    rule location ( )
    {
        if ! $(self.file-location)
        {
            local source-location = [ $(self.project).get source-location ] ;

            for local src-dir in $(source-location)
            {
                if ! $(self.file-location)
                {
                    local location = [ path.root $(self.name) $(src-dir) ] ;
                    if [ CHECK_IF_FILE [ path.native $(location) ] ]
                    {
                         self.file-location = $(src-dir) ;
                         self.file-path = $(location) ;
                    }
                }
            }
        }
        return $(self.file-location) ;
    }
}


if "--quiet" in [ modules.peek : ARGV ]
{
    .quiet = true ;
}


# Given a target-reference, made in context of 'project',
# returns the abstract-target instance that is referred to, as well
# as properties explicitly specified for this reference.
rule resolve-reference ( target-reference : project )
{
    # Separate target name from properties override
    local split = [ MATCH "^([^<]*)(/(<.*))?$" : $(target-reference) ] ;
    local id = $(split[1]) ;
    local sproperties = ;
    if $(split[3])
    {
        sproperties = [ property.make [ feature.split $(split[3]) ] ] ;
        sproperties = [ feature.expand-composites $(sproperties) ] ;
    }

    # Find the target
    local target = [ $(project).find $(id) ] ;
    
    return $(target) [ property-set.create $(sproperties) ] ;
}



# Attempts to generate the target given by target reference, which
# can refer both to a main target or to a file.
# Returns a list consisting of
# - usage requirements
# - generated virtual targets, if any
rule generate-from-reference 
   ( target-reference            # Target reference
    : project                    # Project where the reference is made
    : property-set               # Properties of the main target that 
                                 # makes the reference
   )
{
    local r = [ resolve-reference $(target-reference) : $(project) ] ;
    local target = $(r[1]) ;
    local sproperties = $(r[2]) ;
    
    # Take properties which should be propagated and refine them
    # with source-specific requirements.
    local propagated = [ $(property-set).propagated ] ;
    local rproperties = [ $(propagated).refine $(sproperties) ] ;
    if $(rproperties[1]) = "@error"
    {
        errors.error
          "When building" [ full-name ] " with properties " $(properties) :
            "Invalid properties specified for " $(source) ":"
              $(rproperties[2-]) ;
    }
    return [ $(target).generate $(rproperties) ] ;
}

# Given build request and requirements, return properties
# common to dependency build request and target build
# properties
rule common-properties ( build-request requirements )
{
    # For optimization, we add free requirements directly,
    # without using complex algorithsm.
    # This gives the complex algorithm better chance of caching results.
    local free = [ $(requirements).free ] ;        
    local non-free = [ property-set.create 
        [ $(requirements).base ]  [ $(requirements).incidental ] ] ;
    
    local key = .rp.$(build-request)-$(non-free) ;
    if ! $($(key))
    {           
        $(key) = [ common-properties2 $(build-request) $(non-free) ] ;        
    }        
    result = [ $($(key)).add-raw $(free) ] ;
}
    
rule common-properties2 ( build-request requirements )
{           
    # This guarantees that default properties are present
    # in result, unless they are overrided by some requirement.
    # FIXME: There is possibility that we've added <foo>bar, which is composite
    # and expands to <foo2>bar2, but default value of <foo2> is not bar2,
    # in which case it's not clear what to do.
    # 
    build-request = [ $(build-request).add-defaults ] ;
    # Featured added by 'add-default' can be composite and expand
    # to features without default values -- so they are not added yet.
    # It could be clearer/faster to expand only newly added properties
    # but that's not critical.
    build-request = [ $(build-request).expand ] ;
    
    # Apply non-conditional requirements. 
    # There's a slight bug here: it's possible that conditional
    # requirement change a value set by non-conditional requirements. This
    # should be error, but we don't detect it yet.
    local raw = [ $(build-request).raw ] ;
    raw = [ property.refine $(raw) : 
      [ feature.expand [ $(requirements).non-conditional ] ] ] ;
    
    # We've collected properties that surely must be present in common
    # properties. We now try to figure out what other properties
    # should be added in order to satisfy rules (4)-(6) from the docs.        
    
    local conditionals = [ $(requirements).conditional ] ;
    local count = $(conditionals) and-once-more ;
    local prev ;
    
    local current = $(raw) ;
    
    local ok ;
    while $(count) 
    {
        # Evaluate conditionals in context of current properties
        local e = [ property.evaluate-conditionals-in-context $(conditionals) 
          : $(current) ] ;
        if $(e) = $(prev)
        {                
            # If we got the same result, we've found final properties.
            count = ;      
            ok = true ;
        }         
        else
        {
            # Oops, results of evaluation of conditionals has changes
            # Also 'current' contains leftover from previous evaluation.
            # Recompute 'current' using initial properties and conditional
            # requirements.
            prev = $(e) ;
            current = [ property.refine $(raw) : [ feature.expand $(e) ] ] ;
        }            
        count = $(count[2-]) ;
    }
    if ! $(ok)
    {
        errors.error "Can't evaluate conditional properties " $(conditionals) ;
    }
    
    
    return [ property-set.create $(current) ] ;
}

# Implements the most standard way of constructing main target
# alternative from sources. Allows sources to be either file or
# other main target and handles generation of those dependency
# targets.
class basic-target : abstract-target
{
    import build-request ;
    import virtual-target targets ;
    import property-set ;
    import set sequence errors ;
    import "class" : new ;
    import property feature ;
        
    rule __init__ ( name : project
        : sources * : requirements * : 
        default-build * : usage-requirements * )
    {        
        abstract-target.__init__ $(name) : $(project) ;
    
        self.sources = $(sources) ;
        if ! $(requirements) {
            requirements = [ property-set.empty ] ;
        }    
        self.requirements = $(requirements) ;
        if ! $(default-build) 
        {
            default-build = [ property-set.empty ] ;
        }    
        self.default-build = $(default-build) ;
        if ! $(usage-requirements)
        {
            usage-requirements = [ property-set.empty ] ;
        }    
        self.usage-requirements = $(usage-requirements) ;
        
        if $(sources:G)
        {
            errors.error "gristed element in sources for" [ full-name ] ;
        }
    }
    
    rule requirements ( )
    {
        return $(self.requirements) ;
    }
                        
    rule default-build ( )
    {
        return $(self.default-build) ;
    }
    
    # Returns the alternative condition for this alternative, if
    # the condition is satisfied by 'property-set'.
    rule match ( property-set )
    {    
        # The condition is composed of all base non-conditional properties.
        # It's not clear if we should expand 'self.requirements' or not.
        # For one thing, it would be nice to be able to put
        #    <toolset>msvc-6.0 
        # in requirements.
        # On the other hand, if we have <variant>release in condition it 
        # does not make sense to require <optimization>full to be in
        # build request just to select this variant.
        local bcondition = [ $(self.requirements).base ] ;
        local ccondition = [ $(self.requirements).conditional ] ;
        local condition = [ set.difference $(bcondition) : $(ccondition) ] ;
        if $(condition) in [ $(property-set).raw ] 
        {
            return $(condition) ;            
        }
        else
        {
            return no-match ;
        }        
    }
    
    # Takes a target reference, which might be either target id
    # or a dependency property, and generates that target using
    # 'property-set' as build request.
    #
    # The results are added to to variable called 'result-var'.
    # Usage requirements are added variable called 'usage-requirements-var'.
    rule generate-dependencies ( dependencies * : property-set 
        : result-var usage-requirements-var )
    {
        for local dependency in $(dependencies)
        {            
            local grist = $(dependency:G) ;
            local id = $(dependency:G=) ;
        
            local result = 
              [ targets.generate-from-reference $(id) : $(self.project) 
                : $(property-set) ] ;
        
            $(result-var) += $(result[2-]:G=$(grist)) ;
            $(usage-requirements-var) += [ $(result[1]).raw ] ;
        }        
    }
    
    
    # Determines final build properties, generates sources,
    # and calls 'construct'. This method should not be
    # overridden.
    rule generate ( property-set )
    {
        if [ modules.peek : .debug-building ] 
        {
            ECHO [ targets.indent ] "Building target '$(self.name)'" ;
            ECHO [ targets.indent ] "Build request: " [ $(property-set).raw ] ;
            targets.increase-indent ;
        }
                
        if ! $(self.generated.$(property-set)) 
        {           
            local rproperties = [ targets.common-properties $(property-set) 
              $(self.requirements) ] ;           
            
            if [ modules.peek : .debug-building ] 
            {
                ECHO [ targets.indent ] "Common properties are" [ $(rproperties).raw ] ;
            }
                        
            if $(rproperties[1]) != "@error"                    
            {
                local source-targets ;
                local properties = [ $(rproperties).non-dependency ] ;
                local usage-requirements ;
                
                generate-dependencies [ $(rproperties).dependency ]
                  : $(rproperties) 
                  : properties usage-requirements ;
                
                generate-dependencies $(self.sources) : $(rproperties)
                  : source-targets usage-requirements ;
                
                if [ modules.peek : .debug-building ] 
                {
                    ECHO [ targets.indent ] 
                      "Usage requirements for $(self.name) are $(usage-requirements)" ;
                }

                rproperties = [ property-set.create $(properties) 
                  $(usage-requirements) ] ;
                usage-requirements = [ property-set.create $(usage-requirements) ] ;
                
                local extra = [ $(rproperties).get <source> ] ;                
                source-targets += $(extra:G=) ;
                # We might get duplicate sources, for example if
                # we link to two library which have the same <library> in
                # usage requirements.
                source-targets = [ sequence.unique $(source-targets) ] ;
                                                               
                local result = 
                  [ construct $(self.name) : 
                    $(source-targets) : $(rproperties) ] ;
                
                local gur = $(result[1]) ;
                result = $(result[2-]) ;

                local s = [ create-subvariant $(result) : $(property-set) : $(source-targets)
                  : $(rproperties) : $(usage-requirements) ] ;

                local ur = [ compute-usage-requirements $(s) ] ;
                ur = [ $(ur).add $(gur) ] ;
                $(s).set-usage-requirements $(ur) ;
                self.generated.$(property-set) = $(ur) $(result) ;
            } 
            else
            {
                self.generated.$(property-set) = $(rproperties) ;
            }       
        }                
        else
        {
            if [ modules.peek : .debug-building ] 
            {
                ECHO [ targets.indent ] "Already built" ;
            }            
        }
        
        
        targets.decrease-indent ;
        return $(self.generated.$(property-set)) ;
    }

    # Given the set of generated targets, and refined build 
    # properties, determines and sets appripriate usage requirements
    # on those targets.
    rule compute-usage-requirements ( subvariant )
    {
        local rproperties = [ $(subvariant).build-properties ] ;
        xusage-requirements = [ $(self.usage-requirements).evaluate-conditionals 
          $(rproperties) ] ;                
        
        # We generate all dependency properties and add them,
        # as well as their usage requirements, to result.
        local extra ;
        generate-dependencies [ $(xusage-requirements).dependency ] :
            $(rproperties) : extra extra ;
                
        local result = [ property-set.create
            [ $(xusage-requirements).non-dependency ] $(extra) ] ;
        
        result = [ $(result).add 
          [ $(subvariant).sources-usage-requirements ] ] ;        
        
        return $(result) ;
    }
    
    # Creates a new subvariant-dg instances for 'targets'
    local rule create-subvariant ( targets * : build-request : sources * :
        rproperties 
        : usage-requirements )
    {
        for local e in $(targets)                    
        {
            $(e).root true ;
        }                    
        
        # Process all vtargets that will be created if this main target
        # is created.
        local all-targets = 
          [ sequence.transform virtual-target.traverse : $(targets) ] ; 
        local s = [ new subvariant $(__name__) : $(build-request) : $(sources)
          : $(rproperties) : $(usage-requirements) : $(all-targets) ] ;
        for local v in $(all-targets)          
        {
            if ! [ $(v).creating-subvariant ]
            {                
                $(v).creating-subvariant $(s) ;            
            }            
        }                        
        return $(s) ;
    }
        
    # Constructs the virtual targets for this abstract targets and
    # the dependecy graph. Returns the list of virtual targets.
    # Should be overrided in derived classes.
    rule construct ( name : source-targets * : properties * )
    {
        errors.error "method should be defined in derived classes" ;
    }
}

class typed-target : basic-target
{
    import generators ;    
    
    rule __init__ ( name : project : type 
    : sources * : requirements * : default-build * : usage-requirements * )
    {
        basic-target.__init__ $(name) : $(project) 
          : $(sources) : $(requirements) : $(default-build) : $(usage-requirements) ;
        
        self.type = $(type) ;
    }
    
    rule type ( )
    {
        return $(self.type) ;
    }
            
    rule construct ( name : source-targets * : property-set )
    {
        local r = [ generators.construct $(self.project) $(name) : $(self.type) 
          : [ property-set.create [ $(property-set).raw ] # [ feature.expand
              <main-target-type>$(self.type) ]
          # ]
            : $(source-targets) ] ;
        if ! $(r)
        {
            errors.error "unable to construct" [ full-name ] ;
        }
        
        return $(r) ;
    }            
}

# Return the list of sources to use, if main target rule is invoked
# with 'sources'. If there are any objects in 'sources', they are treated
# as main target instances, and WRITEME.
rule main-target-sources ( sources * : main-target-name )
{
    local result ;
    for local t in $(sources)
    {
        if [ class.is-instance $(t) ]
        {
            local name = [ $(t).name ] ;
            # NOTE: on windows, this won't work if 'main-target-name'
            # if single letter. But other alternatives are even worse.
            local new-name = $(main-target-name)..$(name) ;
            $(t).rename $(new-name) ;
            #local p = [ $(t).project ] ;            
            #local pt = [ project.target $(p) ] ;
            #$(pt).rename-main-target $(name) : $(new-name) ;
            result += $(new-name) ;
        }
        else
        {
            result += $(t) ;
        }                
    }    
    return $(result) ;
}


# Returns the requirement to use when declaring a main target,
# which are obtained by
# - translating all specified property paths, and
# - refining project requirements with the one specified for the target
rule main-target-requirements ( 
  specification * # Properties explicitly specified for a main target
  : project       # Project where the main target is to be declared
      )
{
    local loc = [ $(project).get location ] ;
    local jamfile-module = [ $(project).project-module ] ;
    local requirements = [ property-set.create-from-user-input $(specification)
      : $(jamfile-module) $(loc) ] ;
    
    local project-requirements = [ $(project).get requirements ] ;
    requirements = [ $(project-requirements).refine $(requirements) ] ;    
    if $(requirements[1]) = "@error" 
    {
        errors.error "Conflicting requirements for target:" $(requirements) ;
    }
    return $(requirements) ;
}

# Returns the use requirement to use when declaraing a main target,
# which are obtained by
# - translating all specified property paths, and
# - adding project's usage requirements
rule main-target-usage-requirements (
  specification * # Use-properties explicitly specified for a main target
  : project       # Project where the main target is to be declared
     )
{
    local loc = [ $(project).get location ] ;         
    local project-usage-requirements = [ $(project).get usage-requirements ] ;
        
    local usage-requirements = [ property-set.create 
        [ property.translate-paths $(specification) : $(loc) ] ] ;
    
    return [ $(project-usage-requirements).add $(usage-requirements) ] ;
}

# Return the default build value to use when declaring a main target,
# which is obtained by using specified value if not empty and parent's
# default build attribute otherwise.
rule main-target-default-build (
  specification * # Default build explicitly specified for a main target
  : project       # Project where the main target is to be declared
     )
{
    local result ;
    if $(specification)
    {
        result = $(specification) ;
    }
    else
    {
        result = [ $(project).get default-build ] ;
    }    
    return [ property-set.create-with-validation $(result) ] ;
}         

# Registers the specified target as a main target alternatives.
# Returns 'target'.
rule main-target-alternative ( target ) 
{               
    local ptarget = [ $(target).project ] ;
    
    $(ptarget).add-alternative $(target) ;
    return $(target) ;
}

# Creates a typed-target with the specified properties.
# The 'name', 'sources', 'requirements', 'default-build' and
# 'usage-requirements' are assumed to be in the form specified
# by the user in Jamfile corresponding to 'project'.
rule create-typed-target ( type : project : 
    name : sources * : requirements * : default-build * 
    : usage-requirements * )
{
    return [
      targets.main-target-alternative
      [ new typed-target $(name) : $(project) : $(type)
        : [ targets.main-target-sources $(sources) : $(name) ] 
        : [ targets.main-target-requirements $(requirements) : $(project) ] 
        : [ targets.main-target-default-build $(default-build) : $(project) ]
        : [ targets.main-target-usage-requirements $(usage-requirements) : $(project) ]
      ] ] ;

}
